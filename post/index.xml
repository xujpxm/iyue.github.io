<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on IYue 爱月 | XUJPXM的博客</title>
    <link>https://www.iyue.pub/post/</link>
    <description>Recent content in Posts on IYue 爱月 | XUJPXM的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>xujpxm</copyright>
    <lastBuildDate>Sun, 28 Jun 2020 12:49:18 +0800</lastBuildDate>
    
	<atom:link href="https://www.iyue.pub/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go学习每日一问(3)-make</title>
      <link>https://www.iyue.pub/post/go-question-make/</link>
      <pubDate>Sun, 28 Jun 2020 12:49:18 +0800</pubDate>
      
      <guid>https://www.iyue.pub/post/go-question-make/</guid>
      <description>&lt;p&gt;每次学习并整理一个Golang的知识点，每天进步一点点。今天来学习下make的一个知识点🤔。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go学习每日一问(2)-range</title>
      <link>https://www.iyue.pub/post/go-question-range/</link>
      <pubDate>Tue, 23 Jun 2020 19:16:17 +0800</pubDate>
      
      <guid>https://www.iyue.pub/post/go-question-range/</guid>
      <description>&lt;p&gt;每次学习并整理一个Golang的知识点，每天进步一点点。今天来学习下range的一个知识点🤔。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go学习每日一问(1)-defer</title>
      <link>https://www.iyue.pub/post/go-question-defer/</link>
      <pubDate>Thu, 18 Jun 2020 18:15:53 +0800</pubDate>
      
      <guid>https://www.iyue.pub/post/go-question-defer/</guid>
      <description>&lt;p&gt;每次学习并整理一个Golang的知识点，每天进步一点点🤔。今天我们来看下defer函数相关的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>从源码看Prometheus的远程写调优</title>
      <link>https://www.iyue.pub/post/prometheus-remote-write/</link>
      <pubDate>Sun, 17 May 2020 03:41:53 +0800</pubDate>
      
      <guid>https://www.iyue.pub/post/prometheus-remote-write/</guid>
      <description>&lt;p&gt;本周在配置Prometheus的远端存储的时，发现配置完运行一段时间后，日志中有警告信息: &lt;strong&gt;&amp;ldquo;Skipping resharding, last successful send was beyond threshold&amp;rdquo;&lt;/strong&gt;；排查后发现，原来Prometheus对remote write的配置在最佳实践中早有提及相关优化建议。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Grafana为Dashboard添加独立权限控制</title>
      <link>https://www.iyue.pub/post/grafana-folder-permission/</link>
      <pubDate>Tue, 12 May 2020 19:16:29 +0800</pubDate>
      
      <guid>https://www.iyue.pub/post/grafana-folder-permission/</guid>
      <description>&lt;p&gt;Grafana作为一款开源的度量分析与可视化套件，已经得到了大家的认可并被广泛使用，他可用于基础设施的时序监控数据展示，应用程序数据分析可视化，另外在包括气象、家庭自动化和过程控制等其他领域也使用广泛。Grafana支持Mysql、Elasticsearch、Prometheus、InfluxDB等众多数据源，每个数据源都有一个特定的查询编辑器，可以根据自己的业务需要，撰写多种表达式，绘制多种数据展示图表。但有时你绘制的图表信息，如若涉及敏感信息，不想被所有人看到的时候，该怎么办呢？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>听说你的Nginx还不会记录Response Body?</title>
      <link>https://www.iyue.pub/post/nginx-log-with-response-body/</link>
      <pubDate>Fri, 01 May 2020 10:24:29 +0800</pubDate>
      
      <guid>https://www.iyue.pub/post/nginx-log-with-response-body/</guid>
      <description>&lt;p&gt;相信大家都遇到过在排查线上问题或Debug的时候，在某一瞬间，特别想开启Nginx的Response Body日志，来帮助自己快速的定位问题；但找半天发现只有request_body/upstream_addr/upstream_response_time这些相近变量可用；这个时候不要慌&amp;hellip; 其实Nginx默认不开启Response Body的日志记录是有原因的，因为在Response Body过大，比如返回一个静态页面等内容时，不仅造成大量的资源占用，更会造成整个日志文件的可读性下降；但假如我们明确Response Body的格式，或想捕获Body里的关键字内容的时候，可以通过结合lua模块来实现这一需求。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Nginx缓存开启</title>
      <link>https://www.iyue.pub/post/nginx-cache/</link>
      <pubDate>Sun, 10 Jun 2018 17:08:09 +0800</pubDate>
      
      <guid>https://www.iyue.pub/post/nginx-cache/</guid>
      <description>&lt;p&gt;众所周知，Nginx是一个高性能的web服务器，尤其在高并发和处理静态页面的时候有先天的优势；很大一部分得益于缓存的开启，那么如何开启nginx的缓存呢。&lt;/p&gt;
&lt;p&gt;简单来说可以分两步：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Prometheus基于文件的服务发现</title>
      <link>https://www.iyue.pub/post/prometheus-fd-config/</link>
      <pubDate>Sun, 10 Jun 2018 17:01:26 +0800</pubDate>
      
      <guid>https://www.iyue.pub/post/prometheus-fd-config/</guid>
      <description>&lt;p&gt;Prometheus是一套开源的监控、报警解决方案，是由SoundCloud公司开发的，从 2012 年开始编写代码，再到 2015 年 开源以来，该项目有非常活跃的社区和开发人员，目前在全世界最大的男性交友社区上已经有了1.1w多star；2016 年 Prometheus 成为继 k8s 后，成为第二名 CNCF(Cloud Native Computing Foundation) 成员。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Supervisord守护Prometheus遇到的坑</title>
      <link>https://www.iyue.pub/post/supervisor-with-prometheus/</link>
      <pubDate>Sun, 10 Jun 2018 16:37:18 +0800</pubDate>
      
      <guid>https://www.iyue.pub/post/supervisor-with-prometheus/</guid>
      <description>&lt;p&gt;一直以来我采用supervisord来进行第三方服务的管理，百试不爽。所谓的第三方服务，我这里把不能通过yum或apt进行安装的，统统归拢为第三方；当然使用systemd来进行管理也很不错，不过在服务exit的时候需要自己写脚本来进行重启和重试操作。不例外的，Prometheus我还是采用了supervisord来进行启动管理，但是过完年后上班发现，我的prometheus无法收集targets的监控数据了，8百多个监控接口的数据丢了三天；排查后发现是由于supervisor引起的。于是整理出来，大家分享一下我的排查路线。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux中MemFree与MemAvailable的区别</title>
      <link>https://www.iyue.pub/post/memfree-memavailable/</link>
      <pubDate>Sat, 26 May 2018 23:15:14 +0800</pubDate>
      
      <guid>https://www.iyue.pub/post/memfree-memavailable/</guid>
      <description>&lt;p&gt;最近在做Prometheus的监控，结合Grafana做前端展示，其中涉及到内存的时候，有不少人对Memory Free和Memory Avaliable这两个参数比较疑惑，这里结合linux下常用的查看内存使用情况的free命令，做下整理。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>高并发下Linux系统及kernel参数优化</title>
      <link>https://www.iyue.pub/post/linux-high-concurrency/</link>
      <pubDate>Thu, 24 May 2018 01:51:44 +0800</pubDate>
      
      <guid>https://www.iyue.pub/post/linux-high-concurrency/</guid>
      <description>&lt;p&gt;众所周知在默认参数情况下Linux对高并发支持并不好，主要受限于单进程最大打开文件数限制、内核TCP参数方面和IO事件分配机制等。下面就从几方面来调整使Linux系统能够支持高并发环境。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>